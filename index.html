<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>財運タイムアタック（1万円→30秒）リズム＆態度ロジック版</title>
  <style>
    :root{
      --bg:#0b0f1a; --panel:#0d1433; --line:#22306a;
      --txt:#e8ecff; --muted:rgba(232,236,255,.78);
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif;}
    .wrap{max-width:1020px;margin:0 auto;padding:16px;display:flex;flex-direction:column;gap:12px;}
    .top{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .stats{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{background:rgba(13,20,51,.75);backdrop-filter: blur(6px);
      border:1px solid rgba(34,48,106,.9);border-radius:999px;padding:8px 12px;font-size:13px}
    .pill b{font-size:14px}
    .actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:#1b2550;color:#fff;border:1px solid #2a3a7a;border-radius:12px;padding:9px 12px;cursor:pointer}
    button:active{transform:translateY(1px)}
    button.secondary{background:transparent;border:1px solid rgba(34,48,106,.95);color:var(--txt)}
    button.big{padding:14px 16px;border-radius:16px;font-weight:1000;font-size:16px;letter-spacing:.02em}
    .grid{display:grid;grid-template-columns: 1.2fr .8fr; gap:12px}
    @media (max-width:900px){ .grid{grid-template-columns:1fr;} }

    .panel{
      border-radius:18px; padding:14px; position:relative; overflow:hidden;
      border:1px solid rgba(34,48,106,.92);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(147,180,255,.10), rgba(0,0,0,0)),
        radial-gradient(1200px 600px at 90% 0%, rgba(255,77,109,.08), rgba(0,0,0,0)),
        linear-gradient(180deg, rgba(10,16,40,.95), rgba(7,10,22,.95));
      box-shadow: 0 22px 55px rgba(0,0,0,.35);
      transform: translate3d(0,0,0);
    }
    .panel.right{background:linear-gradient(180deg, rgba(10,16,40,.95), rgba(7,10,22,.95));}

    .title{font-weight:1000;font-size:18px}
    .hint{font-size:13px;color:var(--muted);line-height:1.55}
    .tiny{font-size:12px;color:rgba(232,236,255,.72)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}

    /* reserve space for fortuneBar */
    .center{
      display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center;
      min-height:520px;
      padding-top:82px;
    }
    .moneyBig{font-size:46px;font-weight:1000;letter-spacing:.02em;text-shadow:0 10px 26px rgba(0,0,0,.45)}
    .subRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center}

    .drawBtn{
      width:min(420px, 84vw);
      padding:18px 18px;
      border-radius:22px;
      background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.18), rgba(0,0,0,0)),
                 linear-gradient(180deg, rgba(255,212,59,.98), rgba(240,180,41,.88));
      border:2px solid rgba(255,255,255,.22);
      box-shadow:0 18px 40px rgba(0,0,0,.40), inset 0 8px 18px rgba(255,255,255,.22);
      cursor:pointer; user-select:none; -webkit-tap-highlight-color:transparent;
      display:flex; align-items:center; justify-content:center;
      color:#2a1f00;
      transition: transform .06s ease, filter .2s ease;
      font-weight:1000;
      font-size:18px;
      letter-spacing:.04em;
    }
    .drawBtn:active{transform:scale(.985)}
    .drawBtn.disabled{opacity:.55; pointer-events:none; filter:grayscale(.2);}

    .sideBtn{
      width:min(200px, 40vw);
      padding:14px 12px;
      border-radius:16px;
      background:rgba(13,20,51,.78);
      border:1px solid rgba(34,48,106,.9);
      box-shadow:0 16px 34px rgba(0,0,0,.28);
      font-weight:1000;
    }
    .sideBtn.good{border-color:rgba(255,120,120,.6)}
    .sideBtn.bad{border-color:rgba(120,150,180,.55)}
    .sideBtn.disabled{opacity:.55; pointer-events:none; filter:grayscale(.2);}
    .smallRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center}

    /* Fortune Bar */
    .fortuneBar{
      position:absolute;
      left:14px; right:14px; top:14px;
      height:64px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 14px;
      gap:12px;
      box-shadow: 0 12px 28px rgba(0,0,0,.35);
      z-index: 3;
    }
    .fortuneLabel{
      font-weight:1000;
      font-size:26px;
      letter-spacing:.04em;
      text-shadow:0 10px 28px rgba(0,0,0,.55);
      white-space:nowrap;
    }
    .fortuneDelta{
      font-weight:900;
      font-size:14px;
      color:rgba(232,236,255,.92);
      opacity:.95;
      white-space:nowrap;
      text-align:right;
      line-height:1.25;
    }

    /* red for good, dark for bad */
    .fortune-daikichi { background: linear-gradient(90deg, rgba(255,60,60,.55), rgba(0,0,0,.20)); }
    .fortune-chukichi { background: linear-gradient(90deg, rgba(255,110,60,.45), rgba(0,0,0,.20)); }
    .fortune-shokichi { background: linear-gradient(90deg, rgba(255,170,70,.34), rgba(0,0,0,.20)); }
    .fortune-kichi    { background: linear-gradient(90deg, rgba(230,220,120,.22), rgba(0,0,0,.20)); }
    .fortune-suekichi { background: linear-gradient(90deg, rgba(180,190,210,.18), rgba(0,0,0,.20)); }
    .fortune-kyo      { background: linear-gradient(90deg, rgba(90,110,130,.22), rgba(0,0,0,.28)); }
    .fortune-daikyo   { background: linear-gradient(90deg, rgba(10,14,22,.55), rgba(0,0,0,.35)); }

    .fortune-daikichi .fortuneLabel{color: rgba(255,90,90,1);}
    .fortune-chukichi .fortuneLabel{color: rgba(255,140,90,1);}
    .fortune-shokichi .fortuneLabel{color: rgba(255,200,120,1);}
    .fortune-kichi    .fortuneLabel{color: rgba(255,240,170,1);}
    .fortune-suekichi .fortuneLabel{color: rgba(210,220,240,1);}
    .fortune-kyo      .fortuneLabel{color: rgba(170,190,215,1);}
    .fortune-daikyo   .fortuneLabel{color: rgba(160,160,175,1);}

    .toast{
      position:absolute;left:14px;top:88px;
      background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);
      padding:8px 10px;border-radius:12px;font-size:13px;
      opacity:0;transform:translateY(-6px);transition:.18s;
      backdrop-filter: blur(8px);
      z-index: 3;
    }
    .toast.show{opacity:1;transform:translateY(0)}

    .float{
      position:absolute; pointer-events:none; font-weight:950;
      text-shadow:0 2px 16px rgba(0,0,0,.45);
      animation: floatUp .95s cubic-bezier(.12,.9,.2,1) forwards;
      will-change: transform, opacity;
      letter-spacing:.02em;
      z-index: 3;
    }
    @keyframes floatUp{
      0%{transform:translate(-50%,-8px) scale(1); opacity:1}
      100%{transform:translate(-50%,-120px) scale(1.22); opacity:0}
    }

    canvas.fx{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:2; }

    .card{
      background:rgba(13,20,51,.78); backdrop-filter: blur(8px);
      border:1px solid rgba(34,48,106,.9); border-radius:14px;
      padding:12px; display:flex; flex-direction:column; gap:10px;
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    select{
      background:rgba(13,20,51,.9); color:var(--txt);
      border:1px solid rgba(34,48,106,.95); border-radius:12px;
      padding:10px 12px; font-size:14px; min-width:260px;
    }
    .hr{height:1px;background:rgba(255,255,255,.08);margin:8px 0}

    /* Result modal */
    .modalBackdrop{
      position:fixed; inset:0; background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center; padding:18px;
    }
    .modal{
      width:min(820px, 100%); background:#0c122a; border:1px solid rgba(34,48,106,.95);
      border-radius:18px; padding:16px; box-shadow:0 30px 80px rgba(0,0,0,.55);
    }
    .modal h2{margin:0 0 8px 0; font-size:22px}
    .resultCard{
      background:rgba(13,20,51,.78); border:1px solid rgba(34,48,106,.9); border-radius:14px;
      padding:14px; line-height:1.7;
    }
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border-bottom:1px solid rgba(255,255,255,.10);padding:8px 6px;text-align:left;font-size:13px}
    th{color:rgba(232,236,255,.85)}
    .badge{
      display:inline-block; padding:3px 8px; border-radius:999px;
      border:1px solid rgba(34,48,106,.9);
      background:rgba(147,180,255,.12);
      font-size:12px;
    }
    .modalBtns{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;margin-top:12px}

    @media print{
      body{background:#fff;color:#000}
      .wrap, .top, .grid, .panel, .actions, .stats, .hint, canvas.fx, .toast, .fortuneBar{display:none !important;}
      .modalBackdrop{position:static; inset:auto; background:none; display:block !important; padding:0}
      .modal{box-shadow:none; border:0; border-radius:0; padding:0}
      .modalBtns{display:none !important;}
      .resultCard{border:1px solid #000; background:#fff}
      th,td{border-bottom:1px solid #000;color:#000}
      .badge{border:1px solid #000;background:#fff}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="stats">
      <div class="pill">残り：<b id="time">30.0</b>s</div>
      <div class="pill">所持金：<b id="money">10,000</b>円</div>
      <div class="pill">開始：<b class="mono">¥10,000</b></div>
      <div class="pill">モード：<b id="modeName">未選択</b></div>
      <div class="pill">回数：<b id="presses">0</b></div>
      <div class="pill">偏り：<b id="biasMeter">0.00</b></div>
      <div class="pill">リズム：<b id="rhythmMeter">0.00</b></div>
    </div>
    <div class="actions">
      <button id="btnAudio">Audio ON</button>
      <button id="btnReset" class="secondary">Reset</button>
    </div>
  </div>

  <div class="grid">
    <div class="panel" id="leftPanel">
      <canvas class="fx" id="fx"></canvas>

      <div class="fortuneBar fortune-kichi" id="fortuneBar">
        <div class="fortuneLabel" id="fortuneLabel">—</div>
        <div class="fortuneDelta mono" id="fortuneDelta"></div>
      </div>

      <div class="toast" id="toast"></div>

      <div class="center">
        <div class="moneyBig mono" id="moneyBig">¥10,000</div>
        <div class="hint">
          30秒で、所持金10,000円をどれだけ増やせるか。<br>
          <b>リズム良く押すと大吉寄り</b>。<b>連打＆不安定だと凶寄り</b>。<br>
          さらに「ありがとう／もっと頑張れよ」で運勢の偏りを操作できる。
        </div>

        <div class="drawBtn disabled" id="drawBtn">財運を引く（押す）</div>

        <div class="smallRow">
          <button class="sideBtn good disabled" id="btnThanks">ありがとう</button>
          <button class="sideBtn bad disabled" id="btnHarsh">もっと頑張れよ</button>
        </div>

        <div class="subRow">
          <button class="big" id="btnStart">スタート（30秒）</button>
          <button class="big secondary" id="btnEnd">終了（結果）</button>
        </div>

        <div class="tiny">※ 「ありがとう」は運を上げるが、連打で雑に押すと逆効果っぽく感じるようにしてある。</div>
      </div>
    </div>

    <div class="panel right">
      <div class="card">
        <div class="title">モード選択</div>
        <div class="tiny">基本の出やすさと振れ幅が変わる。</div>
        <div class="row">
          <select id="mode">
            <option value="steady">安定（凶が出にくい／増減は小さめ）</option>
            <option value="balanced" selected>バランス（ほどよく増減）</option>
            <option value="risky">博打（大吉も凶も出やすい／増減が激しい）</option>
          </select>
        </div>

        <div class="hr"></div>

        <div class="title">一般的な7段階</div>
        <div class="tiny">大吉 ＞ 中吉 ＞ 小吉 ＞ 吉 ＞ 末吉 ＞ 凶 ＞ 大凶</div>
        <div class="row">
          <span class="badge">大吉</span>
          <span class="badge">中吉</span>
          <span class="badge">小吉</span>
          <span class="badge">吉</span>
          <span class="badge">末吉</span>
          <span class="badge">凶</span>
          <span class="badge">大凶</span>
        </div>

        <div class="hr"></div>

        <div class="hint">
          追加ロジック：<br>
          ・<b>ありがとう</b>：短時間だけ良い方へ寄る（偏り +）<br>
          ・<b>もっと頑張れよ</b>：短時間だけ悪い方へ寄る（偏り −）<br>
          ・メインボタンは<b>リズムが安定</b>すると良い方へ寄る／<b>連打＆不安定</b>だと悪い方へ寄る
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modalBackdrop" id="modalBackdrop">
  <div class="modal">
    <h2>結果</h2>
    <div class="resultCard">
      <div class="resultBig" id="resultTitle">総合判定：—</div>
      <div id="resultSummary" style="margin-top:6px"></div>

      <table>
        <thead><tr><th>運勢</th><th>回数</th><th>割合</th></tr></thead>
        <tbody id="countTable"></tbody>
      </table>

      <div style="margin-top:10px" id="resultTypeLine"></div>
      <div style="margin-top:6px" id="resultAdviceLine"></div>
      <div style="margin-top:10px">お疲れ様でした。</div>
    </div>

    <div class="modalBtns">
      <button class="secondary" id="btnClose">閉じる</button>
      <button id="btnPrint">印刷</button>
      <button id="btnAgain">もう一回</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== DOM =====
  const timeEl = document.getElementById("time");
  const moneyEl = document.getElementById("money");
  const moneyBigEl = document.getElementById("moneyBig");
  const pressesEl = document.getElementById("presses");
  const modeNameEl = document.getElementById("modeName");
  const biasMeterEl = document.getElementById("biasMeter");
  const rhythmMeterEl = document.getElementById("rhythmMeter");

  const leftPanel = document.getElementById("leftPanel");
  const drawBtn = document.getElementById("drawBtn");
  const btnThanks = document.getElementById("btnThanks");
  const btnHarsh = document.getElementById("btnHarsh");
  const btnStart = document.getElementById("btnStart");
  const btnEnd = document.getElementById("btnEnd");
  const btnAudio = document.getElementById("btnAudio");
  const btnReset = document.getElementById("btnReset");
  const modeSel = document.getElementById("mode");

  const toastEl = document.getElementById("toast");
  const fortuneBar = document.getElementById("fortuneBar");
  const fortuneLabel = document.getElementById("fortuneLabel");
  const fortuneDelta = document.getElementById("fortuneDelta");

  const modalBackdrop = document.getElementById("modalBackdrop");
  const resultTitle = document.getElementById("resultTitle");
  const resultSummary = document.getElementById("resultSummary");
  const countTable = document.getElementById("countTable");
  const resultTypeLine = document.getElementById("resultTypeLine");
  const resultAdviceLine = document.getElementById("resultAdviceLine");
  const btnClose = document.getElementById("btnClose");
  const btnPrint = document.getElementById("btnPrint");
  const btnAgain = document.getElementById("btnAgain");

  // ===== Audio =====
  let audioCtx = null;
  let audioUnlocked = false;
  let muted = false;
  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioUnlocked = true;
  }
  function beep({freq=440, dur=0.06, type="sine", gain=0.05, when=0, slide=0}={}){
    if (muted || !audioUnlocked) return;
    ensureAudio();
    const t0 = audioCtx.currentTime + when;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    if (slide) o.frequency.exponentialRampToValueAtTime(Math.max(30, freq + slide), t0 + dur);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }
  const sfx = {
    tap(){ beep({freq: 880, dur:0.045, type:"square", gain:0.035, slide:-220}); },
    good(){ beep({freq: 659, dur:0.08, type:"triangle", gain:0.06}); beep({freq: 880, dur:0.10, type:"triangle", gain:0.06, when:0.08}); },
    bad(){  beep({freq: 180, dur:0.10, type:"sawtooth", gain:0.05, slide:-60}); },
    boom(){ beep({freq: 220, dur:0.12, type:"sawtooth", gain:0.06, slide:-120}); beep({freq: 440, dur:0.10, type:"triangle", gain:0.05, when:0.06}); },
    end(){  beep({freq: 784, dur:0.10, type:"triangle", gain:0.06}); beep({freq: 659, dur:0.10, type:"triangle", gain:0.06, when:0.11}); beep({freq: 523, dur:0.12, type:"triangle", gain:0.06, when:0.22}); },
    thanks(){ beep({freq: 523, dur:0.07, type:"triangle", gain:0.06}); beep({freq: 659, dur:0.08, type:"triangle", gain:0.06, when:0.07}); },
    harsh(){ beep({freq: 220, dur:0.08, type:"sawtooth", gain:0.05}); }
  };

  // ===== FX Canvas =====
  const fx = document.getElementById("fx");
  const fctx = fx.getContext("2d");
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const particles = [];
  const rings = [];
  function rand(a,b){ return a + Math.random()*(b-a); }
  function hsl(h,s,l,a=1){ return `hsla(${h},${s}%,${l}%,${a})`; }
  function resizeFx(){
    const r = leftPanel.getBoundingClientRect();
    fx.width = Math.floor(r.width * DPR);
    fx.height = Math.floor(r.height * DPR);
  }
  window.addEventListener("resize", resizeFx);

  function pushSparks(x,y,amount=20,power=1){
    for (let i=0;i<amount;i++){
      const ang = rand(0, Math.PI*2);
      const sp = rand(160, 420)*power;
      const hue = (Math.random()*360)|0;
      particles.push({
        type:"spark",
        x,y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp,
        g: rand(480, 820),
        life: rand(0.45, 0.75),
        t: 0,
        r: rand(1.2, 2.6),
        color: hsl(hue, 98, 64, 0.95)
      });
    }
  }
  function pushConfetti(burst=70){
    const r = leftPanel.getBoundingClientRect();
    const cx = r.width*0.5, cy=r.height*0.30;
    for (let i=0;i<burst;i++){
      const hue = (Math.random()*360)|0;
      particles.push({
        type:"confetti",
        x: cx + rand(-60,60),
        y: cy + rand(-30,30),
        vx: rand(-160,160),
        vy: rand(-280,-140),
        g: rand(380,520),
        life: rand(1.1, 1.9),
        t: 0,
        rot: rand(0,Math.PI*2),
        vr: rand(-10,10),
        w: rand(5,11),
        h: rand(9,18),
        color: hsl(hue, 95, 60, 0.95)
      });
    }
  }
  function pushRing(x,y){
    rings.push({x,y,r:10,vr:520,life:0.55,t:0,color:hsl(rand(0,360),95,62,0.75)});
  }
  function fxLoop(now){
    fctx.clearRect(0,0,fx.width,fx.height);
    fctx.save(); fctx.scale(DPR,DPR);
    const dt = Math.min(0.033, (fxLoop._last ? (now - fxLoop._last)/1000 : 0.016));
    fxLoop._last = now;

    for (let i=rings.length-1;i>=0;i--){
      const it=rings[i]; it.t += dt; it.r += it.vr*dt;
      const a = 1 - (it.t / it.life);
      if (a<=0){ rings.splice(i,1); continue; }
      fctx.beginPath();
      fctx.strokeStyle = it.color.replace("0.75", String(0.75*a));
      fctx.lineWidth = 4*a;
      fctx.arc(it.x,it.y,it.r,0,Math.PI*2);
      fctx.stroke();
    }

    for (let i=particles.length-1;i>=0;i--){
      const p=particles[i]; p.t += dt;
      const a = 1 - (p.t / p.life);
      if (a<=0){ particles.splice(i,1); continue; }
      p.vy += p.g*dt; p.x += p.vx*dt; p.y += p.vy*dt;

      if (p.type==="confetti"){
        p.rot += p.vr*dt;
        fctx.save();
        fctx.translate(p.x,p.y);
        fctx.rotate(p.rot);
        fctx.globalAlpha = Math.max(0,a);
        fctx.fillStyle = p.color;
        fctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
        fctx.restore();
      } else {
        fctx.globalAlpha = Math.max(0,a);
        fctx.fillStyle = p.color;
        fctx.beginPath();
        fctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        fctx.fill();
      }
    }

    fctx.restore();
    requestAnimationFrame(fxLoop);
  }

  // ===== UI helpers =====
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=>toastEl.classList.remove("show"), 950);
  }
  function spawnFloat(text, x, y, size=18, color="rgba(255,212,59,1)"){
    const el=document.createElement("div");
    el.className="float";
    el.textContent=text;
    el.style.left=x+"px";
    el.style.top=y+"px";
    el.style.fontSize=size+"px";
    el.style.color=color;
    leftPanel.appendChild(el);
    setTimeout(()=>el.remove(), 1000);
  }

  // ===== Fortune Bar =====
  function fortuneClass(name){
    return {
      "大吉":"fortune-daikichi",
      "中吉":"fortune-chukichi",
      "小吉":"fortune-shokichi",
      "吉":"fortune-kichi",
      "末吉":"fortune-suekichi",
      "凶":"fortune-kyo",
      "大凶":"fortune-daikyo",
    }[name] || "fortune-kichi";
  }
  function showFortuneBar(name, delta, infoLine=""){
    fortuneBar.classList.remove(
      "fortune-daikichi","fortune-chukichi","fortune-shokichi",
      "fortune-kichi","fortune-suekichi","fortune-kyo","fortune-daikyo"
    );
    fortuneBar.classList.add(fortuneClass(name));
    fortuneLabel.textContent = name;

    let line1 = "";
    if (typeof delta === "number"){
      const sign = delta >= 0 ? "+" : "−";
      line1 = `${sign}¥${Math.floor(Math.abs(delta)).toLocaleString("ja-JP")}`;
    }
    fortuneDelta.innerHTML = `${line1}${infoLine ? "<br>"+infoLine : ""}`;

    fortuneBar.animate(
      [{transform:"scale(1)", filter:"brightness(1)"},
       {transform:"scale(1.015)", filter:"brightness(1.15)"},
       {transform:"scale(1)", filter:"brightness(1)"}],
      {duration:220, easing:"ease-out"}
    );
  }

  // ===== Fortune System =====
  const ORDER = ["大吉","中吉","小吉","吉","末吉","凶","大凶"];

  // baseline mode weights (order same as ORDER)
  const modeWeights = {
    steady:   [10, 14, 18, 22, 22, 10,  4],
    balanced: [ 9, 12, 16, 22, 22, 12,  7],
    risky:    [12, 13, 12, 18, 15, 18, 12],
  };
  const modeLabel = { steady:"安定", balanced:"バランス", risky:"博打" };

  // money delta strength
  const fortuneMult = {
    "大吉": +12,
    "中吉": +7,
    "小吉": +4,
    "吉":   +2,
    "末吉": +1,
    "凶":   -4,
    "大凶": -9
  };
  const modeVolatility = { steady:0.85, balanced:1.0, risky:1.25 };

  // ===== New: Bias (attitude) + Rhythm influence =====
  // bias: -1..+1 (ありがとうで+、もっと頑張れよで-). time-decays.
  // rhythm: -1..+1 (安定で+、連打/不安定で-). computed from recent intervals.
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function weightedPick(names, weights){
    const total = weights.reduce((a,b)=>a+b,0);
    let r = Math.random()*total;
    for (let i=0;i<weights.length;i++){
      r -= weights[i];
      if (r<=0) return names[i];
    }
    return names[names.length-1];
  }

  function applyInfluenceToWeights(baseW, bias, rhythm){
    // baseW array length 7
    // bias(+): push toward good (index 0..2). bias(-): push toward bad (index 5..6)
    // rhythm(+): push toward good. rhythm(-): push toward bad.
    // effect strength is moderate so it "feels" but not deterministic.
    const w = baseW.slice();

    // combine influence
    const influ = clamp(0.55*bias + 0.75*rhythm, -1, 1); // rhythm stronger than attitude
    const goodBoost = Math.max(0, influ);
    const badBoost  = Math.max(0, -influ);

    // good side: indices 0,1,2; bad: 5,6; mid: 3,4
    // boost distribution
    w[0] *= (1 + 0.85*goodBoost);
    w[1] *= (1 + 0.55*goodBoost);
    w[2] *= (1 + 0.35*goodBoost);

    // mid slightly reduced when goodBoost high (keeps total consistent-ish)
    w[3] *= (1 - 0.18*goodBoost);
    w[4] *= (1 - 0.10*goodBoost);

    // bad amplified when badBoost
    w[5] *= (1 + 0.70*badBoost);
    w[6] *= (1 + 1.10*badBoost);

    // when badBoost, reduce good a bit
    w[0] *= (1 - 0.22*badBoost);
    w[1] *= (1 - 0.18*badBoost);
    w[2] *= (1 - 0.12*badBoost);

    // avoid collapse
    for (let i=0;i<w.length;i++) w[i] = Math.max(0.5, w[i]);

    return w;
  }

  // rhythm scoring:
  // target interval ~ 380ms (comfortable rhythm)
  // too fast (<160ms) => bad
  // unstable (high variance) => bad
  function computeRhythmScore(intervals){
    if (intervals.length < 4) return 0;

    const ms = intervals.slice(-8); // last up to 8
    const n = ms.length;
    const mean = ms.reduce((a,b)=>a+b,0)/n;

    // variance
    const varr = ms.reduce((a,b)=>a+(b-mean)*(b-mean),0)/n;
    const sd = Math.sqrt(varr);

    // speed score: closer to target better; too fast is punished
    const target = 380;
    const dist = Math.abs(mean - target);
    let speedScore = 1 - clamp(dist/420, 0, 1); // 0..1

    // too fast penalty
    const tooFast = mean < 160 ? (160 - mean)/120 : 0; // 0..~1
    speedScore = speedScore - clamp(tooFast, 0, 1);

    // stability score: lower sd better
    const stabilityScore = 1 - clamp(sd/220, 0, 1); // 0..1

    // spam penalty: if last interval extremely short
    const last = ms[n-1];
    const spamPenalty = last < 120 ? 0.9 : (last < 160 ? 0.55 : 0);

    let score01 = 0.55*speedScore + 0.45*stabilityScore;
    score01 = score01 - spamPenalty;

    // map to -1..+1
    const score = clamp((score01*2 - 1), -1, 1);
    return score;
  }

  // ===== Game State =====
  const state = {
    startMoney: 10000,
    money: 10000,
    running: false,
    tLeft: 30.0,
    presses: 0,
    mode: "balanced",
    counts: Object.fromEntries(ORDER.map(k=>[k,0])),
    maxMoney: 10000,
    minMoney: 10000,

    // new
    bias: 0,             // -1..+1
    rhythm: 0,           // -1..+1
    lastMainAt: 0,
    intervals: [],       // ms list
  };

  function setEnabled(on){
    drawBtn.classList.toggle("disabled", !on);
    btnThanks.classList.toggle("disabled", !on);
    btnHarsh.classList.toggle("disabled", !on);
  }

  function moneyInt(){ return Math.floor(state.money + 1e-9); }
  function yen(n){ return "¥" + Math.floor(n).toLocaleString("ja-JP"); }

  function updateTop(){
    timeEl.textContent = state.tLeft.toFixed(1);
    moneyEl.textContent = moneyInt().toLocaleString("ja-JP");
    moneyBigEl.textContent = yen(state.money);
    pressesEl.textContent = String(state.presses);
    modeNameEl.textContent = modeLabel[state.mode] || "—";
    biasMeterEl.textContent = state.bias.toFixed(2);
    rhythmMeterEl.textContent = state.rhythm.toFixed(2);
  }

  function resetAll(){
    modalBackdrop.style.display = "none";
    state.mode = modeSel.value;
    state.money = state.startMoney;
    state.tLeft = 30.0;
    state.running = false;
    state.presses = 0;
    state.counts = Object.fromEntries(ORDER.map(k=>[k,0]));
    state.maxMoney = state.startMoney;
    state.minMoney = state.startMoney;

    state.bias = 0;
    state.rhythm = 0;
    state.lastMainAt = 0;
    state.intervals = [];

    setEnabled(false);
    updateTop();
    showFortuneBar("—", undefined, "偏り 0.00 / リズム 0.00");
    toast("準備OK。モード選んでスタート。");
  }

  function startGame(){
    state.mode = modeSel.value;
    state.money = state.startMoney;
    state.tLeft = 30.0;
    state.running = true;
    state.presses = 0;
    state.counts = Object.fromEntries(ORDER.map(k=>[k,0]));
    state.maxMoney = state.startMoney;
    state.minMoney = state.startMoney;

    state.bias = 0;
    state.rhythm = 0;
    state.lastMainAt = 0;
    state.intervals = [];

    setEnabled(true);
    sfx.boom();
    showFortuneBar("吉", 0, "偏り 0.00 / リズム 0.00");
    toast(`開始：所持金 ${yen(state.money)} / モード：${modeLabel[state.mode]}`);
    updateTop();
  }

  function endGame(){
    if (!state.running) { showResults(); return; }
    state.running = false;
    setEnabled(false);
    sfx.end();
    toast("結果を表示するよ。");
    showResults();
  }

  function decayBias(dt){
    // bias naturally decays toward 0 (half-life-ish)
    const k = 1.6; // larger = faster decay
    state.bias *= Math.exp(-k * dt);
    // tiny deadzone
    if (Math.abs(state.bias) < 0.01) state.bias = 0;
  }

  function pressThanks(){
    if (!state.running) return;
    // gratitude increases bias, but spam reduces effect slightly (feels "雑だと効かない")
    const now = performance.now();
    const recently = (now - (pressThanks._last||0)) < 250;
    pressThanks._last = now;

    const add = recently ? 0.05 : 0.10;
    state.bias = clamp(state.bias + add, -1, 1);
    sfx.thanks();
    toast("ありがとう…運が少し寄った");
    pushConfetti(16);
    showFortuneBar(fortuneLabel.textContent || "吉", undefined, `偏り ${state.bias.toFixed(2)} / リズム ${state.rhythm.toFixed(2)}`);
    updateTop();
  }

  function pressHarsh(){
    if (!state.running) return;
    const now = performance.now();
    const recently = (now - (pressHarsh._last||0)) < 250;
    pressHarsh._last = now;

    const add = recently ? 0.06 : 0.12;
    state.bias = clamp(state.bias - add, -1, 1);
    sfx.harsh();
    toast("もっと頑張れよ…運が悪い方へ寄った");
    pushConfetti(8);
    showFortuneBar(fortuneLabel.textContent || "凶", undefined, `偏り ${state.bias.toFixed(2)} / リズム ${state.rhythm.toFixed(2)}`);
    updateTop();
  }

  function pickFortuneWithLogic(){
    const baseW = modeWeights[state.mode] || modeWeights.balanced;
    const w = applyInfluenceToWeights(baseW, state.bias, state.rhythm);
    return weightedPick(ORDER, w);
  }

  function doDraw(ev){
    if (!state.running) return;

    // measure rhythm based on main button timings
    const now = performance.now();
    if (state.lastMainAt > 0){
      const interval = now - state.lastMainAt;
      state.intervals.push(interval);
      if (state.intervals.length > 14) state.intervals.shift();
    }
    state.lastMainAt = now;
    state.rhythm = computeRhythmScore(state.intervals);

    const rectPanel = leftPanel.getBoundingClientRect();
    const x = (ev?.clientX ?? (rectPanel.left + rectPanel.width/2)) - rectPanel.left;
    const y = (ev?.clientY ?? (rectPanel.top  + rectPanel.height*0.52)) - rectPanel.top;

    const f = pickFortuneWithLogic();
    state.counts[f]++;

    const vol = modeVolatility[state.mode] ?? 1.0;

    const base = 90 + Math.min(210, state.presses * 1.2);
    let delta = base * (fortuneMult[f]) * vol;

    // spice: when rhythm very good, occasionally upgrade (feels rewarding)
    if (state.rhythm > 0.70 && (f === "中吉" || f === "小吉") && Math.random() < 0.10) {
      delta *= 1.25;
    }
    // penalty: spammy rhythm -> extra pain on bad
    if (state.rhythm < -0.65 && (f === "凶" || f === "大凶") && Math.random() < 0.12) {
      delta *= 1.20;
    }

    const before = state.money;
    state.money = clamp(state.money + delta, 0, 1e12);
    state.presses++;

    state.maxMoney = Math.max(state.maxMoney, state.money);
    state.minMoney = Math.min(state.minMoney, state.money);

    // show bar with info
    showFortuneBar(f, delta, `偏り ${state.bias.toFixed(2)} / リズム ${state.rhythm.toFixed(2)}`);

    // FX
    sfx.tap();
    const abs = Math.abs(delta);
    const power = clamp(0.7 + Math.log10(abs+10)*0.25, 0.7, 2.0);
    pushRing(x, y);
    pushSparks(x, y, Math.floor(10 + power*12), power);

    if (f === "大吉") pushConfetti(28);
    if (f === "大凶") pushConfetti(10);

    if (delta > 0) sfx.good();
    if (delta < 0) sfx.bad();

    const sign = delta >= 0 ? "+" : "−";
    const text = `${sign}${yen(abs)}`;
    const color = delta < 0 ? "rgba(255,77,109,1)" : "rgba(125,255,202,1)";
    spawnFloat(text, x, y, abs >= 3000 ? 28 : 20, color);

    if (abs >= 5000) toast(delta > 0 ? "ドカ増え！" : "ドカ減り！");
    if (before < 10000 && state.money >= 10000) toast("1万円ライン復帰！");
    if (before < 20000 && state.money >= 20000) toast("2万円突破！");
    if (before < 50000 && state.money >= 50000) toast("5万円突破！");

    updateTop();
  }

  // ===== Timer loop =====
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    if (state.running){
      state.tLeft -= dt;
      decayBias(dt); // attitude bias decays over time
      if (state.tLeft <= 0){
        state.tLeft = 0;
        updateTop();
        endGame();
      } else {
        updateTop();
      }
    }
    requestAnimationFrame(loop);
  }

  // ===== Results =====
  function pct(n, total){
    if (!total) return "0%";
    return Math.round((n/total)*100) + "%";
  }
  function judgeTotal(net){
    if (net >= 40000) return "宇宙級（爆増）";
    if (net >= 20000) return "大勝ち";
    if (net >= 8000)  return "勝ち";
    if (net >= 0)     return "微勝ち";
    if (net >= -5000) return "微負け";
    if (net >= -15000)return "負け";
    return "大負け";
  }
  function decideType(){
    const total = state.presses || 1;
    const c = state.counts;
    const good = c["大吉"] + c["中吉"] + c["小吉"];
    const bad  = c["凶"] + c["大凶"];
    const mid  = c["吉"] + c["末吉"];
    const goodRate = good / total;
    const badRate  = bad  / total;
    const net = moneyInt() - state.startMoney;
    const range = state.maxMoney - state.minMoney;

    // 6 types + incorporate bias/rhythm flavor
    if (state.rhythm > 0.55 && goodRate > 0.36) return {type:"リズム職人型", advice:"一定のテンポが財運を呼ぶ。今日は“同じ間隔”が武器。"};
    if (state.rhythm < -0.55 && badRate > 0.30) return {type:"連打破壊型", advice:"焦りの連打が損を呼ぶ。間を置くと運が戻る。"};
    if (state.bias > 0.35) return {type:"感謝増幅型", advice:"丁寧さが運を上げる。余計な一押しを我慢すると勝てる。"};
    if (state.bias < -0.35) return {type:"自己圧型", advice:"自分を責めると運が落ちる。言葉を優しくすると回る。"};
    if (range >= 25000) return {type:"ジェットコースター型", advice:"増えた直後が危険。『増えたら守る』をルール化すると強い。"};
    return {type:"堅実積み上げ型", advice:"派手さより継続が勝つ。小さな勝ちを積むと伸びる。"};
  }

  function showResults(){
    const total = state.presses || 0;
    const final = moneyInt();
    const net = final - state.startMoney;
    const judge = judgeTotal(net);
    const t = decideType();

    resultTitle.textContent = `総合判定：${judge}`;
    const netText = (net >= 0) ? `+${net.toLocaleString("ja-JP")}` : `${net.toLocaleString("ja-JP")}`;
    resultSummary.innerHTML =
      `<div>開始：<b class="mono">¥10,000</b> ／ 終了：<b class="mono">${yen(final)}</b> ／ 獲得コイン数：<b class="mono">${netText}</b> 円</div>
       <div>モード：<b>${modeLabel[state.mode]}</b> ／ 回数：<b>${total}</b> ／ 最大：<b class="mono">${yen(state.maxMoney)}</b> ／ 最小：<b class="mono">${yen(state.minMoney)}</b></div>
       <div>最終：偏り <b class="mono">${state.bias.toFixed(2)}</b> ／ リズム <b class="mono">${state.rhythm.toFixed(2)}</b></div>`;

    countTable.innerHTML = "";
    for (const name of ORDER){
      const n = state.counts[name] || 0;
      const tr = document.createElement("tr");
      tr.innerHTML = `<td><span class="badge">${name}</span></td><td>${n}</td><td>${pct(n, total)}</td>`;
      countTable.appendChild(tr);
    }
    resultTypeLine.innerHTML = `あなたのタイプ：<b>${t.type}</b> です`;
    resultAdviceLine.textContent = `注意：${t.advice}`;
    modalBackdrop.style.display = "flex";
  }

  // ===== Events =====
  btnAudio.addEventListener("click", ()=>{
    ensureAudio();
    muted = false;
    btnAudio.textContent = "Audio READY";
    setTimeout(()=>btnAudio.textContent="Audio ON", 800);
  });

  btnReset.addEventListener("click", ()=>{
    ensureAudio();
    if (!confirm("リセットする？")) return;
    resetAll();
  });

  btnStart.addEventListener("click", ()=>{
    ensureAudio();
    modalBackdrop.style.display = "none";
    startGame();
  });

  btnEnd.addEventListener("click", ()=>{
    ensureAudio();
    endGame();
  });

  drawBtn.addEventListener("click", (e)=>doDraw(e));
  drawBtn.addEventListener("touchstart", (e)=>{ doDraw(e.touches[0]); }, {passive:true});

  btnThanks.addEventListener("click", ()=>pressThanks());
  btnHarsh.addEventListener("click", ()=>pressHarsh());

  btnClose.addEventListener("click", ()=>{ modalBackdrop.style.display="none"; });
  btnPrint.addEventListener("click", ()=>{ window.print(); });
  btnAgain.addEventListener("click", ()=>{
    ensureAudio();
    modalBackdrop.style.display="none";
    startGame();
  });

  // Init
  resizeFx();
  requestAnimationFrame(fxLoop);
  resetAll();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>